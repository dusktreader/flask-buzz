{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"flask-buzz","text":"<p>py-buzz bindings specifically for Flask applications</p>"},{"location":"#overview","title":"Overview","text":"<p>This package extends the functionality from the <code>py-buzz</code> package to add some sugar for Flask apps.  <code>FlaskBuzz</code> provides an exception handler builder to create nice error responses with the right status code and information included in the response body. This means that client code can simply register an error handler with their Flask app to supply fully prepared api responses for specific exception types.</p> <p>Setting up you Flask app to return nicely formatted error responses when custom exceptions are raised is as simple as:</p> <ul> <li>Deriving a custom exception class from <code>FlaskBuzz</code></li> <li>Registering the error handler with your Flask app</li> </ul> <p>See examples/basic.py</p>"},{"location":"features/","title":"Features","text":""},{"location":"features/#error-codes","title":"Error Codes","text":"<p>Each <code>FlaskBuzz</code> exception has a <code>status_code</code> class attribute. This should correlate to the type of problem that happened. For example, the default is the generic <code>INTERNAL_SERVICE_ERROR</code> (500). This just means there was a problem in the application code itself. It is recommended to use different, informative status codes for your different derived error classes.</p>"},{"location":"features/#flask-compatible-jsonify","title":"Flask compatible jsonify","text":"<p>In order to make packaging exceptions into normal Flask responses easy, this library adds a <code>jsonify()</code> method. This method composes a Flask response with the <code>status_code</code> and the exception message included in the body (the <code>status_code</code> is still set in the response as well)</p> <p>For example, your route/resource might want to raise a custom exception on certain behaviors and have a response that informs of the error:</p> <pre><code>class InvalidParameters(FlaskBuzz):\n    status_code = http.HTTPStatus.PRECONDITION_FAILED\n\n\ndef check_params(id=None, **params):\n    if not id:\n        raise InvalidParameters('id field must be defined')\n\n\n@app.route('/')\ndef index():\n    params = flask.request.args\n    try:\n        check_params(**params)\n        return flask.jsonify(message='All good!')\n    except FlaskBuzz as err:\n        return err.jsonify()\n</code></pre>"},{"location":"features/#install-error-handler-for-flask","title":"Install error handler for Flask","text":"<p>The <code>flask-buzz</code> package also has the ability to set up a Flask error handler for <code>FlaskBuzz exceptions</code>. This allows any code called in the course of request to raise a <code>FlaskBuzz</code> derived exception and have flask return a properly \"jsonified\" error response:</p> <pre><code>app.register_error_handler(*FlaskBuzz.build_error_handler())\n\n\n@app.route('/')\ndef index():\n    raise FlaskBuzz('Boom!')\n</code></pre> <p>Note</p> <p>Notice that the unpack/splat (<code>*</code>) operator is applied to the return value of <code>build_error_handler</code>. This is because Flask's <code>register_error_handler</code> takes two arguments:</p> <ul> <li>The type of exception to handle</li> <li>A function that should be passed exception instances when they are caught</li> </ul> <p><code>FlaskBuzz</code> returns a tuple that includes:</p> <ul> <li>The class type that is being registered</li> <li>A handler function to call</li> </ul>"},{"location":"features/#adding-tasks-to-error-handlers","title":"Adding tasks to error handlers","text":"<p><code>FlaskBuzz</code> error handlers support adding additional tasks to be executed when a <code>FlaskBuzz</code> exception is handled. For example, you might wish to log the exceptions before returning the response.</p> <p>Each task should be a callable that takes exactly one argument: the exception instance itself. These callables are passed as additional positional arguments:</p> <pre><code>def log_error(err):\n    flask.current_app.logger.error(err)\n\napp.register_error_handler(*FlaskBuzz.build_error_handler(log_error))\n</code></pre>"},{"location":"features/#debug-mode","title":"Debug Mode","text":"<p>By default, the error response provided by <code>FlaskBuzz</code> error handlers include the <code>base_message</code> for the exception. This is important only for exceptions raised by the <code>handle_errors()</code> (or <code>check_expressions()</code>) context manager. This is because <code>handle_errors()</code> includes information about the handled error in its message. The <code>base_message</code> does not include the full message. This is important for production/public apps where you do not wish to expose internal details to clients.</p> <p>If you want to get more information in the response to help with debugging, you can enable \"Debug Mode\" with <code>FlaskBuzz</code> by setting the class property <code>debug</code> to <code>True</code>:</p> <pre><code>FlaskBuzz.debug = True\n</code></pre> <p>When that flag is set, the full error message (including any handled error info) is included in the response. Additionally, a stringified representation of the handled error is also included in the payload. Finally, when \"Debug Mode\" is enabled, the response headers are also included in the body.</p>"},{"location":"quickstart/","title":"Quickstart","text":""},{"location":"quickstart/#requirements","title":"Requirements","text":"<ul> <li>Python 3.10 to 3.13</li> </ul>"},{"location":"quickstart/#installation","title":"Installation","text":""},{"location":"quickstart/#install-from-pypi","title":"Install from pypi:","text":"<p>This will install the latest release from pypi via pip:</p> <pre><code>pip install flask-buzz\n</code></pre>"},{"location":"quickstart/#install-latest-version-from-github","title":"Install latest version from github","text":"<p>If you would like a version other than the latest published on pypi, you may do so by cloning the git repository:</p> <pre><code>git clone https://github.com/dusktreader/flask-buzz.git\n</code></pre> <p>Next, checkout the branch or tag that you wish to use:</p> <pre><code>cd flask-buzz\ngit checkout integration\n</code></pre> <p>Finally, use uv to install from the local directory:</p> <pre><code>uv sync\n</code></pre>"},{"location":"quickstart/#using","title":"Using","text":"<p>See examples/basic.py for an example of how to use this exception package.</p>"},{"location":"reference/","title":"flask-buzz Reference","text":""},{"location":"reference/#flask_buzz","title":"flask_buzz","text":""},{"location":"reference/#flask_buzz.FlaskBuzz","title":"FlaskBuzz","text":"<p>               Bases: <code>Buzz</code></p>"},{"location":"reference/#flask_buzz.FlaskBuzz.build_error_handler","title":"build_error_handler  <code>classmethod</code>","text":"<pre><code>build_error_handler(\n    *tasks: FlaskBuzzTask,\n) -&gt; tuple[type[Self], FlaskBuzzHandler]\n</code></pre> <p>Provides a generic error function that packages a flask_buzz exception so that it can be handled nicely by the flask error handler:</p> <pre><code>app.register_error_handler(FlaskBuzz, FlaskBuzz.build_error_handler())\n</code></pre> <p>Additionally, extra tasks may be applied to the error prior to packaging:</p> <pre><code>app.register_error_handler(FlaskBuzz, build_error_handler(print, lambda e: jawa(e)))\n</code></pre> <p>This latter example will print the error to stdout and also call the <code>jawa()</code> function with the error prior to packaging it for flask's handler</p>"},{"location":"reference/#flask_buzz.FlaskBuzz.jsonify","title":"jsonify","text":"<pre><code>jsonify(\n    status_code: int | None = None,\n    message: str | None = None,\n    headers: HeadersValue | None = None,\n    **kwargs: Any,\n)\n</code></pre> <p>Returns a representation of the error in a jsonic form that is compatible with flask's error handling.</p> <p>Keyword arguments allow custom error handlers to override parts of the exception when it is jsonified.</p> <p>If <code>debug</code> is set, the stringified exception will be included in the response payload. For apps running in production or publicly should not run in debug mode as this could expose internal information to clients.</p> <p>Args:</p> <pre><code>status_code: The status code to include in the response. If not supplied, use instance status_code.\nmessage:     The message to include in the response. If not supplied, use instance message. If debug\n             is set and the base_message is not None, use the base_message instead. This is important,\n             because if the exception was raised by `handle_errors`, the full message will return\n             details of the handled exception as well as the base message. This information should\n             probably not be returned to the client.\nheaders:     The headers to attach to the response. If not supplied, use instance headers. If the\n             instance has no headers, don't include headers.\nkwargs:      Additional fields that should be set in the response body. These must be JSON\n             serializable.\n</code></pre>"}]}